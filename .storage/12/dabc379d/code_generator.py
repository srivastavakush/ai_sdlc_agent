"""Code generation module using LLM"""

import os
import json
from pathlib import Path
from typing import Dict, List
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate

from .utils import log_step

class CodeGenerator:
    """Generates full-stack application code"""
    
    def __init__(self):
        self.llm = ChatOpenAI(
            model="gpt-4o-mini",
            temperature=0.1
        )
    
    def generate_app(self, user_stories: List[str], project_name: str, output_dir: str) -> Dict:
        """
        Generate complete application code from user stories
        
        Args:
            user_stories: List of user stories
            project_name: Name of the project
            output_dir: Directory to output generated code
            
        Returns:
            Dictionary with generated file paths
        """
        try:
            project_path = Path(output_dir) / project_name
            project_path.mkdir(exist_ok=True)
            
            # Create frontend and backend directories
            frontend_path = project_path / "frontend"
            backend_path = project_path / "backend"
            frontend_path.mkdir(exist_ok=True)
            backend_path.mkdir(exist_ok=True)
            
            generated_files = {}
            
            # Generate frontend code
            log_step("Generating React frontend...")
            frontend_files = self._generate_frontend(user_stories, str(frontend_path))
            generated_files.update(frontend_files)
            
            # Generate backend code  
            log_step("Generating Express.js backend...")
            backend_files = self._generate_backend(user_stories, str(backend_path))
            generated_files.update(backend_files)
            
            log_step(f"âœ… Generated {len(generated_files)} code files")
            return generated_files
            
        except Exception as e:
            log_step(f"âŒ Code generation failed: {str(e)}")
            return {}
    
    def _generate_frontend(self, user_stories: List[str], frontend_path: str) -> Dict:
        """Generate React frontend code"""
        files = {}
        
        # Package.json
        package_json = {
            "name": "todo-frontend",
            "version": "0.1.0",
            "private": True,
            "dependencies": {
                "react": "^18.2.0",
                "react-dom": "^18.2.0",
                "react-scripts": "5.0.1",
                "axios": "^1.6.0"
            },
            "scripts": {
                "start": "react-scripts start",
                "build": "react-scripts build",
                "test": "react-scripts test",
                "eject": "react-scripts eject"
            },
            "eslintConfig": {
                "extends": ["react-app", "react-app/jest"]
            },
            "browserslist": {
                "production": [">0.2%", "not dead", "not op_mini all"],
                "development": ["last 1 chrome version", "last 1 firefox version", "last 1 safari version"]
            }
        }
        
        package_path = os.path.join(frontend_path, "package.json")
        with open(package_path, 'w') as f:
            json.dump(package_json, f, indent=2)
        files['frontend_package'] = package_path
        
        # Create public directory
        public_path = os.path.join(frontend_path, "public")
        os.makedirs(public_path, exist_ok=True)
        
        # index.html
        index_html = """<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Todo App - Generated by ZoomToApp</title>
    <style>
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
          'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
          sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      code {
        font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>"""
        
        index_path = os.path.join(public_path, "index.html")
        with open(index_path, 'w') as f:
            f.write(index_html)
        files['frontend_index'] = index_path
        
        # Create src directory
        src_path = os.path.join(frontend_path, "src")
        os.makedirs(src_path, exist_ok=True)
        
        # App.js
        app_js = """import React, { useState, useEffect } from 'react';
import axios from 'axios';
import './App.css';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

function App() {
  const [todos, setTodos] = useState([]);
  const [newTodo, setNewTodo] = useState('');
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchTodos();
  }, []);

  const fetchTodos = async () => {
    try {
      setLoading(true);
      const response = await axios.get(`${API_BASE_URL}/todos`);
      setTodos(response.data);
    } catch (error) {
      console.error('Error fetching todos:', error);
    } finally {
      setLoading(false);
    }
  };

  const addTodo = async (e) => {
    e.preventDefault();
    if (!newTodo.trim()) return;

    try {
      const response = await axios.post(`${API_BASE_URL}/todos`, {
        title: newTodo,
        completed: false
      });
      setTodos([...todos, response.data]);
      setNewTodo('');
    } catch (error) {
      console.error('Error adding todo:', error);
    }
  };

  const toggleTodo = async (id) => {
    try {
      const todo = todos.find(t => t.id === id);
      const response = await axios.put(`${API_BASE_URL}/todos/${id}`, {
        ...todo,
        completed: !todo.completed
      });
      setTodos(todos.map(t => t.id === id ? response.data : t));
    } catch (error) {
      console.error('Error updating todo:', error);
    }
  };

  const deleteTodo = async (id) => {
    try {
      await axios.delete(`${API_BASE_URL}/todos/${id}`);
      setTodos(todos.filter(t => t.id !== id));
    } catch (error) {
      console.error('Error deleting todo:', error);
    }
  };

  return (
    <div className="App">
      <header className="App-header">
        <h1>ðŸ“‹ Todo App</h1>
        <p>Generated by ZoomToApp - AI-Driven SDLC Automation</p>
      </header>
      
      <main className="App-main">
        <form onSubmit={addTodo} className="add-todo-form">
          <input
            type="text"
            value={newTodo}
            onChange={(e) => setNewTodo(e.target.value)}
            placeholder="Enter a new todo..."
            className="todo-input"
          />
          <button type="submit" className="add-button">Add Todo</button>
        </form>

        {loading ? (
          <p>Loading todos...</p>
        ) : (
          <div className="todos-list">
            {todos.length === 0 ? (
              <p>No todos yet. Add one above!</p>
            ) : (
              todos.map(todo => (
                <div key={todo.id} className={`todo-item ${todo.completed ? 'completed' : ''}`}>
                  <span onClick={() => toggleTodo(todo.id)} className="todo-text">
                    {todo.title}
                  </span>
                  <button onClick={() => deleteTodo(todo.id)} className="delete-button">
                    Delete
                  </button>
                </div>
              ))
            )}
          </div>
        )}
      </main>
    </div>
  );
}

export default App;"""
        
        app_path = os.path.join(src_path, "App.js")
        with open(app_path, 'w') as f:
            f.write(app_js)
        files['frontend_app'] = app_path
        
        # App.css
        app_css = """.App {
  text-align: center;
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.App-header {
  background-color: #282c34;
  padding: 20px;
  color: white;
  border-radius: 8px;
  margin-bottom: 30px;
}

.App-header h1 {
  margin: 0;
  font-size: 2rem;
}

.App-header p {
  margin: 10px 0 0 0;
  opacity: 0.8;
}

.App-main {
  max-width: 600px;
  margin: 0 auto;
}

.add-todo-form {
  display: flex;
  gap: 10px;
  margin-bottom: 30px;
}

.todo-input {
  flex: 1;
  padding: 12px;
  font-size: 16px;
  border: 2px solid #ddd;
  border-radius: 6px;
  outline: none;
}

.todo-input:focus {
  border-color: #007bff;
}

.add-button {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 12px 20px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
}

.add-button:hover {
  background-color: #0056b3;
}

.todos-list {
  text-align: left;
}

.todo-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px;
  margin-bottom: 10px;
  background-color: #f8f9fa;
  border-radius: 6px;
  border-left: 4px solid #007bff;
}

.todo-item.completed {
  opacity: 0.6;
  border-left-color: #28a745;
}

.todo-text {
  flex: 1;
  cursor: pointer;
  font-size: 16px;
}

.todo-item.completed .todo-text {
  text-decoration: line-through;
}

.delete-button {
  background-color: #dc3545;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
}

.delete-button:hover {
  background-color: #c82333;
}"""
        
        css_path = os.path.join(src_path, "App.css")
        with open(css_path, 'w') as f:
            f.write(app_css)
        files['frontend_css'] = css_path
        
        # index.js
        index_js = """import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);"""
        
        index_js_path = os.path.join(src_path, "index.js")
        with open(index_js_path, 'w') as f:
            f.write(index_js)
        files['frontend_index_js'] = index_js_path
        
        return files
    
    def _generate_backend(self, user_stories: List[str], backend_path: str) -> Dict:
        """Generate Express.js backend code"""
        files = {}
        
        # Package.json
        package_json = {
            "name": "todo-backend",
            "version": "1.0.0",
            "description": "Todo API backend generated by ZoomToApp",
            "main": "server.js",
            "scripts": {
                "start": "node server.js",
                "dev": "nodemon server.js",
                "test": "jest"
            },
            "dependencies": {
                "express": "^4.18.2",
                "cors": "^2.8.5",
                "sqlite3": "^5.1.6",
                "dotenv": "^16.3.1"
            },
            "devDependencies": {
                "nodemon": "^3.0.1",
                "jest": "^29.7.0",
                "supertest": "^6.3.3"
            }
        }
        
        package_path = os.path.join(backend_path, "package.json")
        with open(package_path, 'w') as f:
            json.dump(package_json, f, indent=2)
        files['backend_package'] = package_path
        
        # server.js
        server_js = """const express = require('express');
const cors = require('cors');
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());

// Database setup
const dbPath = path.join(__dirname, 'todos.db');
const db = new sqlite3.Database(dbPath);

// Initialize database
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS todos (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      title TEXT NOT NULL,
      completed BOOLEAN DEFAULT 0,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);
});

// Routes
app.get('/api/todos', (req, res) => {
  db.all('SELECT * FROM todos ORDER BY created_at DESC', (err, rows) => {
    if (err) {
      res.status(500).json({ error: err.message });
      return;
    }
    res.json(rows);
  });
});

app.post('/api/todos', (req, res) => {
  const { title, completed = false } = req.body;
  
  if (!title) {
    res.status(400).json({ error: 'Title is required' });
    return;
  }
  
  db.run(
    'INSERT INTO todos (title, completed) VALUES (?, ?)',
    [title, completed ? 1 : 0],
    function(err) {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      
      db.get('SELECT * FROM todos WHERE id = ?', [this.lastID], (err, row) => {
        if (err) {
          res.status(500).json({ error: err.message });
          return;
        }
        res.status(201).json(row);
      });
    }
  );
});

app.put('/api/todos/:id', (req, res) => {
  const { id } = req.params;
  const { title, completed } = req.body;
  
  db.run(
    'UPDATE todos SET title = ?, completed = ? WHERE id = ?',
    [title, completed ? 1 : 0, id],
    function(err) {
      if (err) {
        res.status(500).json({ error: err.message });
        return;
      }
      
      if (this.changes === 0) {
        res.status(404).json({ error: 'Todo not found' });
        return;
      }
      
      db.get('SELECT * FROM todos WHERE id = ?', [id], (err, row) => {
        if (err) {
          res.status(500).json({ error: err.message });
          return;
        }
        res.json(row);
      });
    }
  );
});

app.delete('/api/todos/:id', (req, res) => {
  const { id } = req.params;
  
  db.run('DELETE FROM todos WHERE id = ?', [id], function(err) {
    if (err) {
      res.status(500).json({ error: err.message });
      return;
    }
    
    if (this.changes === 0) {
      res.status(404).json({ error: 'Todo not found' });
      return;
    }
    
    res.json({ message: 'Todo deleted successfully' });
  });
});

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

module.exports = app;"""
        
        server_path = os.path.join(backend_path, "server.js")
        with open(server_path, 'w') as f:
            f.write(server_js)
        files['backend_server'] = server_path
        
        return files